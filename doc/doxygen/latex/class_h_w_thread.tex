\hypertarget{class_h_w_thread}{
\subsection{HWThread Class Reference}
\label{class_h_w_thread}\index{HWThread@{HWThread}}
}


Base class for all hardware objects.  


{\ttfamily \#include $<$hw\_\-thread.h$>$}Inheritance diagram for HWThread:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=400pt]{class_h_w_thread__inherit__graph}
\end{center}
\end{figure}
Collaboration diagram for HWThread:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=400pt]{class_h_w_thread__coll__graph}
\end{center}
\end{figure}
\subsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{class_h_w_thread_abd12983f14c80f7fdc515c793f40cf5f}{HWThread} (uint32\_\-t sampling\_\-rate, uint16\_\-t channels, uint16\_\-t \hyperlink{class_h_w_thread_abef19c1294d62c789a37e8f1e1af0c97}{blocks})
\begin{DoxyCompactList}\small\item\em Constructor. \item\end{DoxyCompactList}\item 
\hyperlink{class_h_w_thread_a2b7ecb5fc242836db457edba0fcac11e}{HWThread} ()
\begin{DoxyCompactList}\small\item\em Default constructor. \item\end{DoxyCompactList}\item 
\hypertarget{class_h_w_thread_a6eedcb4f3afa48dd5b265a6799a8cf74}{
virtual \hyperlink{class_h_w_thread_a6eedcb4f3afa48dd5b265a6799a8cf74}{$\sim$HWThread} ()}
\label{class_h_w_thread_a6eedcb4f3afa48dd5b265a6799a8cf74}

\begin{DoxyCompactList}\small\item\em Default destructor. \item\end{DoxyCompactList}\item 
string \hyperlink{class_h_w_thread_a052a0eb8639dda07c3b25df7066194fa}{getName} ()
\begin{DoxyCompactList}\small\item\em Get the name of the device. \item\end{DoxyCompactList}\item 
bool \hyperlink{class_h_w_thread_a0ee653e71f6ac92c96d5d9df2bd986e1}{isMaster} ()
\begin{DoxyCompactList}\small\item\em Check if device is the master. \item\end{DoxyCompactList}\item 
bool \hyperlink{class_h_w_thread_aaab242a33f6739fae59ce7a48d892072}{hasHomogenousSignalType} ()
\begin{DoxyCompactList}\small\item\em Check if device is delivering only one SignalType (e.g. only EEG or only EMG). \item\end{DoxyCompactList}\item 
uint16\_\-t \hyperlink{class_h_w_thread_a563ffea63c9ee8878f91a7b1f04eb58a}{getNrOfBlocks} ()
\begin{DoxyCompactList}\small\item\em Get the blocksize set for the device. \item\end{DoxyCompactList}\item 
uint16\_\-t \hyperlink{class_h_w_thread_acd129796e88e58d3ef2e157e5cbdd156}{getSamplingRate} ()
\begin{DoxyCompactList}\small\item\em Get the sampling rate set for the device. \item\end{DoxyCompactList}\item 
uint16\_\-t \hyperlink{class_h_w_thread_a18e32ba3ca6621edd899196113e1e213}{getNrOfChannels} ()
\begin{DoxyCompactList}\small\item\em Get the number of channels the device is acquiering. \item\end{DoxyCompactList}\item 
vector$<$ uint32\_\-t $>$ \hyperlink{class_h_w_thread_a655f5d40b6ae44cd59db936df49a5c07}{getChannelTypes} ()
\begin{DoxyCompactList}\small\item\em Get a vector containing channel types from acquired channels. \item\end{DoxyCompactList}\item 
map$<$ uint16\_\-t, pair$<$ string, uint32\_\-t $>$ $>$ \hyperlink{class_h_w_thread_a7ea386811b40278f26d54eef9c700c08}{getChannelInfoMap} ()
\begin{DoxyCompactList}\small\item\em Get a map containing all channel information. \item\end{DoxyCompactList}\item 
bool \hyperlink{class_h_w_thread_a240b66ff60434938ca89690cd542dc58}{samplesAvailable} ()
\begin{DoxyCompactList}\small\item\em Check if new samples are available. \item\end{DoxyCompactList}\item 
void \hyperlink{class_h_w_thread_a89a9edf259a4538609b7f4c5be9db14d}{checkMandatoryHardwareTags} (ticpp::Iterator$<$ ticpp::Element $>$ hw)
\begin{DoxyCompactList}\small\item\em Check if all needed hardware tags from xml config are correctly set. \item\end{DoxyCompactList}\item 
virtual \hyperlink{class_sample_block}{SampleBlock}$<$ double $>$ \hyperlink{class_h_w_thread_add1215b3e0f06a856330f2debd7ea2fe}{getSyncData} ()=0
\begin{DoxyCompactList}\small\item\em Abstract method to achieve synchronous data acquisition (method is blocking). \item\end{DoxyCompactList}\item 
virtual \hyperlink{class_sample_block}{SampleBlock}$<$ double $>$ \hyperlink{class_h_w_thread_aa709526a915411a495a947f6bc6e06f9}{getAsyncData} ()=0
\begin{DoxyCompactList}\small\item\em Abstract method to achieve asynchronous data acquisition (method is non-\/blocking). \item\end{DoxyCompactList}\item 
\hypertarget{class_h_w_thread_a2e9f2541e38c3b6b4ef5c28aac570569}{
virtual void \hyperlink{class_h_w_thread_a2e9f2541e38c3b6b4ef5c28aac570569}{run} ()=0}
\label{class_h_w_thread_a2e9f2541e38c3b6b4ef5c28aac570569}

\begin{DoxyCompactList}\small\item\em Abstract method to start data acquisition. \item\end{DoxyCompactList}\end{DoxyCompactItemize}
\subsubsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{class_h_w_thread_a1bd5e440e5f86d0d9af928577c52b262}{setSamplingRate} (ticpp::Iterator$<$ ticpp::Element $>$const \&elem)
\begin{DoxyCompactList}\small\item\em Set the sampling rate of the device. \item\end{DoxyCompactList}\item 
void \hyperlink{class_h_w_thread_a379eecae202ad9b740e08ac22b5d7a42}{setDeviceChannels} (ticpp::Iterator$<$ ticpp::Element $>$const \&elem)
\begin{DoxyCompactList}\small\item\em Set parameters for all channels. \item\end{DoxyCompactList}\item 
void \hyperlink{class_h_w_thread_a8c3dada5e55e8e29eadf41e2097ec80a}{setBlocks} (ticpp::Iterator$<$ ticpp::Element $>$const \&elem)
\begin{DoxyCompactList}\small\item\em Set the blocksize of the device. \item\end{DoxyCompactList}\item 
void \hyperlink{class_h_w_thread_a6ed2a51d2a3a7b9313d1c33f5f507c57}{setChannelSelection} (ticpp::Iterator$<$ ticpp::Element $>$const \&elem)
\begin{DoxyCompactList}\small\item\em Set different parameters for channels (and overwrite settings from $<$measurement\_\-channels$>$). \item\end{DoxyCompactList}\item 
\hypertarget{class_h_w_thread_af0a839e6a139fa0a261a589a6df07de3}{
void \hyperlink{class_h_w_thread_af0a839e6a139fa0a261a589a6df07de3}{setChannelTypes} ()}
\label{class_h_w_thread_af0a839e6a139fa0a261a589a6df07de3}

\begin{DoxyCompactList}\small\item\em Sets the vector channel\_\-types. \item\end{DoxyCompactList}\item 
bool \hyperlink{class_h_w_thread_afc7da1ef263177f3108dcc318208dc60}{isNumber} (const std::string \&s)
\begin{DoxyCompactList}\small\item\em Check, if a string represents a valid number. \item\end{DoxyCompactList}\end{DoxyCompactItemize}
\subsubsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\hypertarget{class_h_w_thread_a316d76b7b23a93f25832b7a575cfb8db}{
uint16\_\-t \hyperlink{class_h_w_thread_a316d76b7b23a93f25832b7a575cfb8db}{nr\_\-ch}}
\label{class_h_w_thread_a316d76b7b23a93f25832b7a575cfb8db}

\begin{DoxyCompactList}\small\item\em number of channels \item\end{DoxyCompactList}\item 
\hypertarget{class_h_w_thread_aed1be0f720f7939e6a0ce1b40a2d15dc}{
uint16\_\-t \hyperlink{class_h_w_thread_aed1be0f720f7939e6a0ce1b40a2d15dc}{fs}}
\label{class_h_w_thread_aed1be0f720f7939e6a0ce1b40a2d15dc}

\begin{DoxyCompactList}\small\item\em sampling rate \item\end{DoxyCompactList}\item 
\hypertarget{class_h_w_thread_ae5a5e40cafce975e55d91f129d8ac4dc}{
bool {\bfseries samples\_\-available}}
\label{class_h_w_thread_ae5a5e40cafce975e55d91f129d8ac4dc}

\item 
\hypertarget{class_h_w_thread_abef19c1294d62c789a37e8f1e1af0c97}{
uint16\_\-t \hyperlink{class_h_w_thread_abef19c1294d62c789a37e8f1e1af0c97}{blocks}}
\label{class_h_w_thread_abef19c1294d62c789a37e8f1e1af0c97}

\begin{DoxyCompactList}\small\item\em blocksize (or also called buffersize) \item\end{DoxyCompactList}\item 
\hypertarget{class_h_w_thread_a7adb2978af51e216016420d5e8629647}{
bool \hyperlink{class_h_w_thread_a7adb2978af51e216016420d5e8629647}{master}}
\label{class_h_w_thread_a7adb2978af51e216016420d5e8629647}

\begin{DoxyCompactList}\small\item\em master: yes or no \item\end{DoxyCompactList}\item 
\hypertarget{class_h_w_thread_add3904adca1c3689bdb7bbc8e72c3b10}{
boost::condition\_\-variable\_\-any \hyperlink{class_h_w_thread_add3904adca1c3689bdb7bbc8e72c3b10}{cond}}
\label{class_h_w_thread_add3904adca1c3689bdb7bbc8e72c3b10}

\begin{DoxyCompactList}\small\item\em condition variable to wake up \hyperlink{class_h_w_thread_add1215b3e0f06a856330f2debd7ea2fe}{getSyncData()} \item\end{DoxyCompactList}\item 
\hypertarget{class_h_w_thread_a36671c08225d5b48837b15180e281380}{
boost::shared\_\-mutex \hyperlink{class_h_w_thread_a36671c08225d5b48837b15180e281380}{rw}}
\label{class_h_w_thread_a36671c08225d5b48837b15180e281380}

\begin{DoxyCompactList}\small\item\em mutex to lock data \item\end{DoxyCompactList}\item 
\hypertarget{class_h_w_thread_adb37cb4524672b5cd2d56e972924a21d}{
boost::mutex \hyperlink{class_h_w_thread_adb37cb4524672b5cd2d56e972924a21d}{sync\_\-mut}}
\label{class_h_w_thread_adb37cb4524672b5cd2d56e972924a21d}

\begin{DoxyCompactList}\small\item\em mutex neede for synchronisation \item\end{DoxyCompactList}\item 
\hypertarget{class_h_w_thread_a172f41a57b5b15ba8cb4a5be4ec9b37b}{
map$<$ uint16\_\-t, pair$<$ string, uint32\_\-t $>$ $>$ \hyperlink{class_h_w_thread_a172f41a57b5b15ba8cb4a5be4ec9b37b}{channel\_\-info}}
\label{class_h_w_thread_a172f41a57b5b15ba8cb4a5be4ec9b37b}

\begin{DoxyCompactList}\small\item\em map containing ( ch\_\-nr, (name, type) ) \item\end{DoxyCompactList}\item 
\hypertarget{class_h_w_thread_afefba9b22ccf22cd983d5f4e5e0fef67}{
bool \hyperlink{class_h_w_thread_afefba9b22ccf22cd983d5f4e5e0fef67}{homogenous\_\-signal\_\-type}}
\label{class_h_w_thread_afefba9b22ccf22cd983d5f4e5e0fef67}

\begin{DoxyCompactList}\small\item\em true, if device delivers different signal types -\/-\/ e.g. EEG and EMG \item\end{DoxyCompactList}\item 
\hypertarget{class_h_w_thread_ac9ba04fa18cf8a115d282f47a7912a00}{
vector$<$ uint32\_\-t $>$ \hyperlink{class_h_w_thread_ac9ba04fa18cf8a115d282f47a7912a00}{channel\_\-types}}
\label{class_h_w_thread_ac9ba04fa18cf8a115d282f47a7912a00}

\begin{DoxyCompactList}\small\item\em vector containing signal types of channels (for faster access) \item\end{DoxyCompactList}\item 
\hypertarget{class_h_w_thread_a114c37f5ef0ab7ae5b4d4342ec051eac}{
map$<$ string, string $>$ \hyperlink{class_h_w_thread_a114c37f5ef0ab7ae5b4d4342ec051eac}{m}}
\label{class_h_w_thread_a114c37f5ef0ab7ae5b4d4342ec051eac}

\begin{DoxyCompactList}\small\item\em map with generic hardware information ... mandatory \item\end{DoxyCompactList}\item 
\hypertarget{class_h_w_thread_a51a8539e21aeb8f54dfebb85ff669ca4}{
map$<$ string, string $>$ \hyperlink{class_h_w_thread_a51a8539e21aeb8f54dfebb85ff669ca4}{m\_\-gs}}
\label{class_h_w_thread_a51a8539e21aeb8f54dfebb85ff669ca4}

\begin{DoxyCompactList}\small\item\em map with global settings ... mandatory \item\end{DoxyCompactList}\item 
\hypertarget{class_h_w_thread_a9ae5abead395b06dfd352c816c8e56dd}{
map$<$ string, string $>$ \hyperlink{class_h_w_thread_a9ae5abead395b06dfd352c816c8e56dd}{m\_\-cs}}
\label{class_h_w_thread_a9ae5abead395b06dfd352c816c8e56dd}

\begin{DoxyCompactList}\small\item\em map with channel specific settings ... optional \item\end{DoxyCompactList}\item 
\hypertarget{class_h_w_thread_ad57accff1aa3bd9f1fe2c291d0a7b1db}{
\hyperlink{class_constants}{Constants} \hyperlink{class_h_w_thread_ad57accff1aa3bd9f1fe2c291d0a7b1db}{cst}}
\label{class_h_w_thread_ad57accff1aa3bd9f1fe2c291d0a7b1db}

\begin{DoxyCompactList}\small\item\em A static object containing constants. \item\end{DoxyCompactList}\item 
\hyperlink{class_sample_block}{SampleBlock}$<$ double $>$ \hyperlink{class_h_w_thread_a64aa44932b8914a5623aa2f1efd4e149}{data}
\begin{DoxyCompactList}\small\item\em Data object representing the last available samples from the \hyperlink{class_sine_generator}{SineGenerator}. \item\end{DoxyCompactList}\end{DoxyCompactItemize}


\subsubsection{Detailed Description}
Base class for all hardware objects. \hyperlink{class_h_w_thread}{HWThread} is the base class for all hardware objects providing abstract methods needed for a common interface to gather access to different types of hardware. It also provides methods and members needed for every data acquisition device (channel types, ...). 

\subsubsection{Constructor \& Destructor Documentation}
\hypertarget{class_h_w_thread_abd12983f14c80f7fdc515c793f40cf5f}{
\index{HWThread@{HWThread}!HWThread@{HWThread}}
\index{HWThread@{HWThread}!HWThread@{HWThread}}
\paragraph[{HWThread}]{\setlength{\rightskip}{0pt plus 5cm}HWThread::HWThread (uint32\_\-t {\em sampling\_\-rate}, \/  uint16\_\-t {\em channels}, \/  uint16\_\-t {\em blocks})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}\hfill}
\label{class_h_w_thread_abd12983f14c80f7fdc515c793f40cf5f}


Constructor. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em sampling\_\-rate}]Sampling rate of the device. \item[\mbox{$\leftarrow$} {\em channels}]Number of channels the device acquires. \item[\mbox{$\leftarrow$} {\em blocks}]Blocksize used by the device. \end{DoxyParams}
\hypertarget{class_h_w_thread_a2b7ecb5fc242836db457edba0fcac11e}{
\index{HWThread@{HWThread}!HWThread@{HWThread}}
\index{HWThread@{HWThread}!HWThread@{HWThread}}
\paragraph[{HWThread}]{\setlength{\rightskip}{0pt plus 5cm}HWThread::HWThread ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}\hfill}
\label{class_h_w_thread_a2b7ecb5fc242836db457edba0fcac11e}


Default constructor. Sets the device to 1 channel, sampling\_\-rate 0 and blocksize 1. 

\subsubsection{Member Function Documentation}
\hypertarget{class_h_w_thread_a89a9edf259a4538609b7f4c5be9db14d}{
\index{HWThread@{HWThread}!checkMandatoryHardwareTags@{checkMandatoryHardwareTags}}
\index{checkMandatoryHardwareTags@{checkMandatoryHardwareTags}!HWThread@{HWThread}}
\paragraph[{checkMandatoryHardwareTags}]{\setlength{\rightskip}{0pt plus 5cm}void HWThread::checkMandatoryHardwareTags (ticpp::Iterator$<$ ticpp::Element $>$ {\em hw})}\hfill}
\label{class_h_w_thread_a89a9edf259a4538609b7f4c5be9db14d}


Check if all needed hardware tags from xml config are correctly set. 
\begin{DoxyParams}{Parameters}
\item[{\em hw}]pointing to the $<$hardware$>$ node in the xml config file \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em ticpp::Exception}]if mandatory hardware tags not correctly set! \end{DoxyExceptions}


Here is the call graph for this function:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=204pt]{class_h_w_thread_a89a9edf259a4538609b7f4c5be9db14d_cgraph}
\end{center}
\end{figure}
\hypertarget{class_h_w_thread_aa709526a915411a495a947f6bc6e06f9}{
\index{HWThread@{HWThread}!getAsyncData@{getAsyncData}}
\index{getAsyncData@{getAsyncData}!HWThread@{HWThread}}
\paragraph[{getAsyncData}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf SampleBlock}$<$double$>$ HWThread::getAsyncData ()\hspace{0.3cm}{\ttfamily  \mbox{[}pure virtual\mbox{]}}}\hfill}
\label{class_h_w_thread_aa709526a915411a495a947f6bc6e06f9}


Abstract method to achieve asynchronous data acquisition (method is non-\/blocking). \begin{DoxyReturn}{Returns}
\hyperlink{class_sample_block}{SampleBlock$<$double$>$}
\end{DoxyReturn}
This method return immediately after calling with a copy of the data stored in the device's buffer. It is called from all slave devices. \begin{DoxyWarning}{Warning}
If hardware clocks are not running with the same sampling rate or drifting (e.g. master -\/ 128Hz, slave 129Hz), this method could be called although no new data is available (master faster than slave) or one sample has been lost (master slower than slave). Up to now no compensation method (e.g. interpolation) has been implemented! 
\end{DoxyWarning}
\begin{Desc}
\item[\hyperlink{todo__todo000009}{Todo}]Implement a compensation method, if clocks are drifting or similar (e.g. interpolation). \end{Desc}


Implemented in \hyperlink{class_sine_generator_ad609b16d89e1d1c762cd94023ea41439}{SineGenerator}, and \hyperlink{class_u_s_bamp_a645a210ffbc5931560f91c8ee6896300}{USBamp}.\hypertarget{class_h_w_thread_a7ea386811b40278f26d54eef9c700c08}{
\index{HWThread@{HWThread}!getChannelInfoMap@{getChannelInfoMap}}
\index{getChannelInfoMap@{getChannelInfoMap}!HWThread@{HWThread}}
\paragraph[{getChannelInfoMap}]{\setlength{\rightskip}{0pt plus 5cm}map$<$uint16\_\-t, pair$<$string, uint32\_\-t$>$ $>$ HWThread::getChannelInfoMap ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}\hfill}
\label{class_h_w_thread_a7ea386811b40278f26d54eef9c700c08}


Get a map containing all channel information. \begin{DoxyReturn}{Returns}
std::map$<$uint16\_\-t channel, pair$<$string channel name, uint32\_\-t channel type$>$ $>$ channel info 
\end{DoxyReturn}
\hypertarget{class_h_w_thread_a655f5d40b6ae44cd59db936df49a5c07}{
\index{HWThread@{HWThread}!getChannelTypes@{getChannelTypes}}
\index{getChannelTypes@{getChannelTypes}!HWThread@{HWThread}}
\paragraph[{getChannelTypes}]{\setlength{\rightskip}{0pt plus 5cm}vector$<$uint32\_\-t$>$ HWThread::getChannelTypes ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}\hfill}
\label{class_h_w_thread_a655f5d40b6ae44cd59db936df49a5c07}


Get a vector containing channel types from acquired channels. \begin{DoxyReturn}{Returns}
std::vector$<$uint16\_\-t$>$ channel\_\-types 
\end{DoxyReturn}
\hypertarget{class_h_w_thread_a052a0eb8639dda07c3b25df7066194fa}{
\index{HWThread@{HWThread}!getName@{getName}}
\index{getName@{getName}!HWThread@{HWThread}}
\paragraph[{getName}]{\setlength{\rightskip}{0pt plus 5cm}string HWThread::getName ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}\hfill}
\label{class_h_w_thread_a052a0eb8639dda07c3b25df7066194fa}


Get the name of the device. \begin{DoxyReturn}{Returns}
string device name 
\end{DoxyReturn}
\hypertarget{class_h_w_thread_a563ffea63c9ee8878f91a7b1f04eb58a}{
\index{HWThread@{HWThread}!getNrOfBlocks@{getNrOfBlocks}}
\index{getNrOfBlocks@{getNrOfBlocks}!HWThread@{HWThread}}
\paragraph[{getNrOfBlocks}]{\setlength{\rightskip}{0pt plus 5cm}uint16\_\-t HWThread::getNrOfBlocks ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}\hfill}
\label{class_h_w_thread_a563ffea63c9ee8878f91a7b1f04eb58a}


Get the blocksize set for the device. \begin{DoxyReturn}{Returns}
uint16\_\-t blocksize 
\end{DoxyReturn}
\hypertarget{class_h_w_thread_a18e32ba3ca6621edd899196113e1e213}{
\index{HWThread@{HWThread}!getNrOfChannels@{getNrOfChannels}}
\index{getNrOfChannels@{getNrOfChannels}!HWThread@{HWThread}}
\paragraph[{getNrOfChannels}]{\setlength{\rightskip}{0pt plus 5cm}uint16\_\-t HWThread::getNrOfChannels ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}\hfill}
\label{class_h_w_thread_a18e32ba3ca6621edd899196113e1e213}


Get the number of channels the device is acquiering. \begin{DoxyReturn}{Returns}
uint16\_\-t nr\_\-of\_\-ch 
\end{DoxyReturn}
\hypertarget{class_h_w_thread_acd129796e88e58d3ef2e157e5cbdd156}{
\index{HWThread@{HWThread}!getSamplingRate@{getSamplingRate}}
\index{getSamplingRate@{getSamplingRate}!HWThread@{HWThread}}
\paragraph[{getSamplingRate}]{\setlength{\rightskip}{0pt plus 5cm}uint16\_\-t HWThread::getSamplingRate ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}\hfill}
\label{class_h_w_thread_acd129796e88e58d3ef2e157e5cbdd156}


Get the sampling rate set for the device. \begin{DoxyReturn}{Returns}
uint16\_\-t sampling\_\-rate 
\end{DoxyReturn}
\hypertarget{class_h_w_thread_add1215b3e0f06a856330f2debd7ea2fe}{
\index{HWThread@{HWThread}!getSyncData@{getSyncData}}
\index{getSyncData@{getSyncData}!HWThread@{HWThread}}
\paragraph[{getSyncData}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf SampleBlock}$<$double$>$ HWThread::getSyncData ()\hspace{0.3cm}{\ttfamily  \mbox{[}pure virtual\mbox{]}}}\hfill}
\label{class_h_w_thread_add1215b3e0f06a856330f2debd7ea2fe}


Abstract method to achieve synchronous data acquisition (method is blocking). \begin{DoxyReturn}{Returns}
\hyperlink{class_sample_block}{SampleBlock$<$double$>$}
\end{DoxyReturn}
This method returns after new data has been acquired, it is operating in blocking mode. It is called only from the master device. 

Implemented in \hyperlink{class_sine_generator_a7c239c664d3559988889cd5d9f90d854}{SineGenerator}, and \hyperlink{class_u_s_bamp_ae5aa6002d425924a95d102f1d890c84c}{USBamp}.

Here is the caller graph for this function:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=169pt]{class_h_w_thread_add1215b3e0f06a856330f2debd7ea2fe_icgraph}
\end{center}
\end{figure}
\hypertarget{class_h_w_thread_aaab242a33f6739fae59ce7a48d892072}{
\index{HWThread@{HWThread}!hasHomogenousSignalType@{hasHomogenousSignalType}}
\index{hasHomogenousSignalType@{hasHomogenousSignalType}!HWThread@{HWThread}}
\paragraph[{hasHomogenousSignalType}]{\setlength{\rightskip}{0pt plus 5cm}bool HWThread::hasHomogenousSignalType ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}\hfill}
\label{class_h_w_thread_aaab242a33f6739fae59ce7a48d892072}


Check if device is delivering only one SignalType (e.g. only EEG or only EMG). \begin{DoxyReturn}{Returns}
bool 
\end{DoxyReturn}
\hypertarget{class_h_w_thread_a0ee653e71f6ac92c96d5d9df2bd986e1}{
\index{HWThread@{HWThread}!isMaster@{isMaster}}
\index{isMaster@{isMaster}!HWThread@{HWThread}}
\paragraph[{isMaster}]{\setlength{\rightskip}{0pt plus 5cm}bool HWThread::isMaster ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}\hfill}
\label{class_h_w_thread_a0ee653e71f6ac92c96d5d9df2bd986e1}


Check if device is the master. \begin{DoxyReturn}{Returns}
bool 
\end{DoxyReturn}
\hypertarget{class_h_w_thread_afc7da1ef263177f3108dcc318208dc60}{
\index{HWThread@{HWThread}!isNumber@{isNumber}}
\index{isNumber@{isNumber}!HWThread@{HWThread}}
\paragraph[{isNumber}]{\setlength{\rightskip}{0pt plus 5cm}bool HWThread::isNumber (const std::string \& {\em s})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}\hfill}
\label{class_h_w_thread_afc7da1ef263177f3108dcc318208dc60}


Check, if a string represents a valid number. \begin{DoxyReturn}{Returns}
bool 
\end{DoxyReturn}
\hypertarget{class_h_w_thread_a240b66ff60434938ca89690cd542dc58}{
\index{HWThread@{HWThread}!samplesAvailable@{samplesAvailable}}
\index{samplesAvailable@{samplesAvailable}!HWThread@{HWThread}}
\paragraph[{samplesAvailable}]{\setlength{\rightskip}{0pt plus 5cm}bool HWThread::samplesAvailable ()}\hfill}
\label{class_h_w_thread_a240b66ff60434938ca89690cd542dc58}


Check if new samples are available. \begin{DoxyReturn}{Returns}
bool 
\end{DoxyReturn}
\hypertarget{class_h_w_thread_a8c3dada5e55e8e29eadf41e2097ec80a}{
\index{HWThread@{HWThread}!setBlocks@{setBlocks}}
\index{setBlocks@{setBlocks}!HWThread@{HWThread}}
\paragraph[{setBlocks}]{\setlength{\rightskip}{0pt plus 5cm}void HWThread::setBlocks (ticpp::Iterator$<$ ticpp::Element $>$const \& {\em elem})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}\hfill}
\label{class_h_w_thread_a8c3dada5e55e8e29eadf41e2097ec80a}


Set the blocksize of the device. 
\begin{DoxyParams}{Parameters}
\item[{\em elem}]pointing to the $<$buffersize$>$ node in the xml config file \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em ticpp::Exception}]if sampling rate is not a number or is zero. \end{DoxyExceptions}
\hypertarget{class_h_w_thread_a6ed2a51d2a3a7b9313d1c33f5f507c57}{
\index{HWThread@{HWThread}!setChannelSelection@{setChannelSelection}}
\index{setChannelSelection@{setChannelSelection}!HWThread@{HWThread}}
\paragraph[{setChannelSelection}]{\setlength{\rightskip}{0pt plus 5cm}void HWThread::setChannelSelection (ticpp::Iterator$<$ ticpp::Element $>$const \& {\em elem})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}\hfill}
\label{class_h_w_thread_a6ed2a51d2a3a7b9313d1c33f5f507c57}


Set different parameters for channels (and overwrite settings from $<$measurement\_\-channels$>$). 
\begin{DoxyParams}{Parameters}
\item[{\em elem}]pointing to the $<$channel\_\-selection$>$ node in the xml config file \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em ticpp::Exception}]if attributes are not correctly set or nr of channels is not a number or zero.\end{DoxyExceptions}
This method also reports, if settings for all channels together have been defined before and overwrites those settings. 

Here is the call graph for this function:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=191pt]{class_h_w_thread_a6ed2a51d2a3a7b9313d1c33f5f507c57_cgraph}
\end{center}
\end{figure}
\hypertarget{class_h_w_thread_a379eecae202ad9b740e08ac22b5d7a42}{
\index{HWThread@{HWThread}!setDeviceChannels@{setDeviceChannels}}
\index{setDeviceChannels@{setDeviceChannels}!HWThread@{HWThread}}
\paragraph[{setDeviceChannels}]{\setlength{\rightskip}{0pt plus 5cm}void HWThread::setDeviceChannels (ticpp::Iterator$<$ ticpp::Element $>$const \& {\em elem})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}\hfill}
\label{class_h_w_thread_a379eecae202ad9b740e08ac22b5d7a42}


Set parameters for all channels. 
\begin{DoxyParams}{Parameters}
\item[{\em elem}]pointing to the $<$measurement\_\-channels$>$ node in the xml config file \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em ticpp::Exception}]if attributes are not correctly set or nr of channels is not a number or zero. \end{DoxyExceptions}


Here is the call graph for this function:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=188pt]{class_h_w_thread_a379eecae202ad9b740e08ac22b5d7a42_cgraph}
\end{center}
\end{figure}
\hypertarget{class_h_w_thread_a1bd5e440e5f86d0d9af928577c52b262}{
\index{HWThread@{HWThread}!setSamplingRate@{setSamplingRate}}
\index{setSamplingRate@{setSamplingRate}!HWThread@{HWThread}}
\paragraph[{setSamplingRate}]{\setlength{\rightskip}{0pt plus 5cm}void HWThread::setSamplingRate (ticpp::Iterator$<$ ticpp::Element $>$const \& {\em elem})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}\hfill}
\label{class_h_w_thread_a1bd5e440e5f86d0d9af928577c52b262}


Set the sampling rate of the device. 
\begin{DoxyParams}{Parameters}
\item[{\em elem}]pointing to the $<$sampling\_\-rate$>$ node in the xml config file \end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
\item[{\em ticpp::Exception}]if sampling rate is not a number or is zero. \end{DoxyExceptions}


\subsubsection{Member Data Documentation}
\hypertarget{class_h_w_thread_a64aa44932b8914a5623aa2f1efd4e149}{
\index{HWThread@{HWThread}!data@{data}}
\index{data@{data}!HWThread@{HWThread}}
\paragraph[{data}]{\setlength{\rightskip}{0pt plus 5cm}{\bf SampleBlock}$<$double$>$ {\bf HWThread::data}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}\hfill}
\label{class_h_w_thread_a64aa44932b8914a5623aa2f1efd4e149}


Data object representing the last available samples from the \hyperlink{class_sine_generator}{SineGenerator}. This \hyperlink{class_sample_block}{SampleBlock} contains the last affordable data for external components. If the buffersize is 1 , than samples will directly be inserted into data, in blockwise mode, \char`\"{}buffer\char`\"{} will be copied into \char`\"{}data\char`\"{}, if the desired number of blocks is achieved. Samples are in ascending order by their signal type. \char`\"{}data\char`\"{} has to be secured by a mutex to cope with the reader/writer problem, as asynchronous data access is also possible. For more information, read the \hyperlink{class_sample_block}{SampleBlock} documentation. 

The documentation for this class was generated from the following files:\begin{DoxyCompactItemize}
\item 
/home/breidi/Dropbox/signalserver/hardware/\hyperlink{hw__thread_8h}{hw\_\-thread.h}\item 
/home/breidi/Dropbox/signalserver/hardware/hw\_\-thread.cpp\end{DoxyCompactItemize}
