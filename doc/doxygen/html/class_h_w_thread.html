<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TOBI SignalServer: HWThread Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>HWThread Class Reference</h1><!-- doxytag: class="HWThread" -->
<p>Base class for all hardware objects.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="hw__thread_8h_source.html">hw_thread.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for HWThread:</div>
<div class="dynsection">
<div class="center"><img src="class_h_w_thread__inherit__graph.png" border="0" usemap="#_h_w_thread_inherit__map" alt="Inheritance graph"/></div>
<map name="_h_w_thread_inherit__map" id="_h_w_thread_inherit__map">
<area shape="rect" href="class_sine_generator.html" title="A dummy hardware device for simulation and testing purposes." alt="" coords="5,851,155,1237"/><area shape="rect" href="class_u_s_bamp.html" title="A class to wrap the API provided by g.tec for the g.USBamp and enable synchronous..." alt="" coords="179,813,312,1275"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for HWThread:</div>
<div class="dynsection">
<div class="center"><img src="class_h_w_thread__coll__graph.png" border="0" usemap="#_h_w_thread_coll__map" alt="Collaboration graph"/></div>
<map name="_h_w_thread_coll__map" id="_h_w_thread_coll__map">
<area shape="rect" href="class_sample_block.html" title="{SampleBlock\&lt; double \&gt;\n|&#45; blocks\l&#45; channels\l&#45; homogenous\l&#45; curr_block\l&#45; types_ordered\l&#45; types_input\l&#45; block_info\l&#45; samples\l|+ SampleBlock()\l+ ~SampleBlock()\l+ getNrOfBlocks()\l+ getNrOfChannels()\l+ getNrOfSamples()\l+ getNrOfSignalTypes()\l+ deleteSamples()\l+ reset()\l+ at()\l+ operator[]()\l+ init()\l+ getTypes()\l+ getSamples()\l+ getFlagByNr()\l+ getSignalByFlag()\l+ getSignalByNr()\l+ appendBlock()\l+ setSamples()\l&#45; sort()\l&#45; checkBlockIntegrity()\l}" alt="" coords="5,1000,165,1573"/><area shape="rect" href="class_sample_block.html" title="A container storing and sorting samples directly acquired from a data acquisition..." alt="" coords="7,5,164,579"/><area shape="rect" href="class_constants.html" title="Class constants manages all constants needed for the signalserver (especially xml..." alt="" coords="189,645,352,1928"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="class_h_w_thread-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_thread.html#abd12983f14c80f7fdc515c793f40cf5f">HWThread</a> (uint32_t sampling_rate, uint16_t channels, uint16_t <a class="el" href="class_h_w_thread.html#abef19c1294d62c789a37e8f1e1af0c97">blocks</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#abd12983f14c80f7fdc515c793f40cf5f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_thread.html#a2b7ecb5fc242836db457edba0fcac11e">HWThread</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor.  <a href="#a2b7ecb5fc242836db457edba0fcac11e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6eedcb4f3afa48dd5b265a6799a8cf74"></a><!-- doxytag: member="HWThread::~HWThread" ref="a6eedcb4f3afa48dd5b265a6799a8cf74" args="()" -->
virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_thread.html#a6eedcb4f3afa48dd5b265a6799a8cf74">~HWThread</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default destructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_thread.html#a052a0eb8639dda07c3b25df7066194fa">getName</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the name of the device.  <a href="#a052a0eb8639dda07c3b25df7066194fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_thread.html#a0ee653e71f6ac92c96d5d9df2bd986e1">isMaster</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if device is the master.  <a href="#a0ee653e71f6ac92c96d5d9df2bd986e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_thread.html#aaab242a33f6739fae59ce7a48d892072">hasHomogenousSignalType</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if device is delivering only one SignalType (e.g. only EEG or only EMG).  <a href="#aaab242a33f6739fae59ce7a48d892072"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_thread.html#a563ffea63c9ee8878f91a7b1f04eb58a">getNrOfBlocks</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the blocksize set for the device.  <a href="#a563ffea63c9ee8878f91a7b1f04eb58a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_thread.html#acd129796e88e58d3ef2e157e5cbdd156">getSamplingRate</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the sampling rate set for the device.  <a href="#acd129796e88e58d3ef2e157e5cbdd156"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_thread.html#a18e32ba3ca6621edd899196113e1e213">getNrOfChannels</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of channels the device is acquiering.  <a href="#a18e32ba3ca6621edd899196113e1e213"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector&lt; uint32_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_thread.html#a655f5d40b6ae44cd59db936df49a5c07">getChannelTypes</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a vector containing channel types from acquired channels.  <a href="#a655f5d40b6ae44cd59db936df49a5c07"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">map&lt; uint16_t, pair&lt; string, <br class="typebreak"/>
uint32_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_thread.html#a7ea386811b40278f26d54eef9c700c08">getChannelInfoMap</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a map containing all channel information.  <a href="#a7ea386811b40278f26d54eef9c700c08"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_thread.html#a240b66ff60434938ca89690cd542dc58">samplesAvailable</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if new samples are available.  <a href="#a240b66ff60434938ca89690cd542dc58"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_thread.html#a89a9edf259a4538609b7f4c5be9db14d">checkMandatoryHardwareTags</a> (ticpp::Iterator&lt; ticpp::Element &gt; hw)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if all needed hardware tags from xml config are correctly set.  <a href="#a89a9edf259a4538609b7f4c5be9db14d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_sample_block.html">SampleBlock</a>&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_thread.html#add1215b3e0f06a856330f2debd7ea2fe">getSyncData</a> ()=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abstract method to achieve synchronous data acquisition (method is blocking).  <a href="#add1215b3e0f06a856330f2debd7ea2fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_sample_block.html">SampleBlock</a>&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_thread.html#aa709526a915411a495a947f6bc6e06f9">getAsyncData</a> ()=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abstract method to achieve asynchronous data acquisition (method is non-blocking).  <a href="#aa709526a915411a495a947f6bc6e06f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e9f2541e38c3b6b4ef5c28aac570569"></a><!-- doxytag: member="HWThread::run" ref="a2e9f2541e38c3b6b4ef5c28aac570569" args="()=0" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_thread.html#a2e9f2541e38c3b6b4ef5c28aac570569">run</a> ()=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abstract method to start data acquisition. <br/></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_thread.html#a1bd5e440e5f86d0d9af928577c52b262">setSamplingRate</a> (ticpp::Iterator&lt; ticpp::Element &gt;const &amp;elem)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the sampling rate of the device.  <a href="#a1bd5e440e5f86d0d9af928577c52b262"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_thread.html#a379eecae202ad9b740e08ac22b5d7a42">setDeviceChannels</a> (ticpp::Iterator&lt; ticpp::Element &gt;const &amp;elem)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set parameters for all channels.  <a href="#a379eecae202ad9b740e08ac22b5d7a42"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_thread.html#a8c3dada5e55e8e29eadf41e2097ec80a">setBlocks</a> (ticpp::Iterator&lt; ticpp::Element &gt;const &amp;elem)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the blocksize of the device.  <a href="#a8c3dada5e55e8e29eadf41e2097ec80a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_thread.html#a6ed2a51d2a3a7b9313d1c33f5f507c57">setChannelSelection</a> (ticpp::Iterator&lt; ticpp::Element &gt;const &amp;elem)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set different parameters for channels (and overwrite settings from &lt;measurement_channels&gt;).  <a href="#a6ed2a51d2a3a7b9313d1c33f5f507c57"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0a839e6a139fa0a261a589a6df07de3"></a><!-- doxytag: member="HWThread::setChannelTypes" ref="af0a839e6a139fa0a261a589a6df07de3" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_thread.html#af0a839e6a139fa0a261a589a6df07de3">setChannelTypes</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the vector channel_types. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_thread.html#afc7da1ef263177f3108dcc318208dc60">isNumber</a> (const std::string &amp;s)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check, if a string represents a valid number.  <a href="#afc7da1ef263177f3108dcc318208dc60"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a316d76b7b23a93f25832b7a575cfb8db"></a><!-- doxytag: member="HWThread::nr_ch" ref="a316d76b7b23a93f25832b7a575cfb8db" args="" -->
uint16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_thread.html#a316d76b7b23a93f25832b7a575cfb8db">nr_ch</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">number of channels <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed1be0f720f7939e6a0ce1b40a2d15dc"></a><!-- doxytag: member="HWThread::fs" ref="aed1be0f720f7939e6a0ce1b40a2d15dc" args="" -->
uint16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_thread.html#aed1be0f720f7939e6a0ce1b40a2d15dc">fs</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">sampling rate <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5a5e40cafce975e55d91f129d8ac4dc"></a><!-- doxytag: member="HWThread::samples_available" ref="ae5a5e40cafce975e55d91f129d8ac4dc" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>samples_available</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abef19c1294d62c789a37e8f1e1af0c97"></a><!-- doxytag: member="HWThread::blocks" ref="abef19c1294d62c789a37e8f1e1af0c97" args="" -->
uint16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_thread.html#abef19c1294d62c789a37e8f1e1af0c97">blocks</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">blocksize (or also called buffersize) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7adb2978af51e216016420d5e8629647"></a><!-- doxytag: member="HWThread::master" ref="a7adb2978af51e216016420d5e8629647" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_thread.html#a7adb2978af51e216016420d5e8629647">master</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">master: yes or no <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add3904adca1c3689bdb7bbc8e72c3b10"></a><!-- doxytag: member="HWThread::cond" ref="add3904adca1c3689bdb7bbc8e72c3b10" args="" -->
boost::condition_variable_any&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_thread.html#add3904adca1c3689bdb7bbc8e72c3b10">cond</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">condition variable to wake up <a class="el" href="class_h_w_thread.html#add1215b3e0f06a856330f2debd7ea2fe" title="Abstract method to achieve synchronous data acquisition (method is blocking).">getSyncData()</a> <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36671c08225d5b48837b15180e281380"></a><!-- doxytag: member="HWThread::rw" ref="a36671c08225d5b48837b15180e281380" args="" -->
boost::shared_mutex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_thread.html#a36671c08225d5b48837b15180e281380">rw</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">mutex to lock data <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb37cb4524672b5cd2d56e972924a21d"></a><!-- doxytag: member="HWThread::sync_mut" ref="adb37cb4524672b5cd2d56e972924a21d" args="" -->
boost::mutex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_thread.html#adb37cb4524672b5cd2d56e972924a21d">sync_mut</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">mutex neede for synchronisation <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a172f41a57b5b15ba8cb4a5be4ec9b37b"></a><!-- doxytag: member="HWThread::channel_info" ref="a172f41a57b5b15ba8cb4a5be4ec9b37b" args="" -->
map&lt; uint16_t, pair&lt; string, <br class="typebreak"/>
uint32_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_thread.html#a172f41a57b5b15ba8cb4a5be4ec9b37b">channel_info</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">map containing ( ch_nr, (name, type) ) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afefba9b22ccf22cd983d5f4e5e0fef67"></a><!-- doxytag: member="HWThread::homogenous_signal_type" ref="afefba9b22ccf22cd983d5f4e5e0fef67" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_thread.html#afefba9b22ccf22cd983d5f4e5e0fef67">homogenous_signal_type</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">true, if device delivers different signal types -- e.g. EEG and EMG <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9ba04fa18cf8a115d282f47a7912a00"></a><!-- doxytag: member="HWThread::channel_types" ref="ac9ba04fa18cf8a115d282f47a7912a00" args="" -->
vector&lt; uint32_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_thread.html#ac9ba04fa18cf8a115d282f47a7912a00">channel_types</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">vector containing signal types of channels (for faster access) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a114c37f5ef0ab7ae5b4d4342ec051eac"></a><!-- doxytag: member="HWThread::m" ref="a114c37f5ef0ab7ae5b4d4342ec051eac" args="" -->
map&lt; string, string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_thread.html#a114c37f5ef0ab7ae5b4d4342ec051eac">m</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">map with generic hardware information ... mandatory <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a51a8539e21aeb8f54dfebb85ff669ca4"></a><!-- doxytag: member="HWThread::m_gs" ref="a51a8539e21aeb8f54dfebb85ff669ca4" args="" -->
map&lt; string, string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_thread.html#a51a8539e21aeb8f54dfebb85ff669ca4">m_gs</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">map with global settings ... mandatory <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ae5abead395b06dfd352c816c8e56dd"></a><!-- doxytag: member="HWThread::m_cs" ref="a9ae5abead395b06dfd352c816c8e56dd" args="" -->
map&lt; string, string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_thread.html#a9ae5abead395b06dfd352c816c8e56dd">m_cs</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">map with channel specific settings ... optional <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad57accff1aa3bd9f1fe2c291d0a7b1db"></a><!-- doxytag: member="HWThread::cst" ref="ad57accff1aa3bd9f1fe2c291d0a7b1db" args="" -->
<a class="el" href="class_constants.html">Constants</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_thread.html#ad57accff1aa3bd9f1fe2c291d0a7b1db">cst</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A static object containing constants. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sample_block.html">SampleBlock</a>&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_thread.html#a64aa44932b8914a5623aa2f1efd4e149">data</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Data object representing the last available samples from the <a class="el" href="class_sine_generator.html" title="A dummy hardware device for simulation and testing purposes.">SineGenerator</a>.  <a href="#a64aa44932b8914a5623aa2f1efd4e149"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Base class for all hardware objects. </p>
<p><a class="el" href="class_h_w_thread.html" title="Base class for all hardware objects.">HWThread</a> is the base class for all hardware objects providing abstract methods needed for a common interface to gather access to different types of hardware. It also provides methods and members needed for every data acquisition device (channel types, ...). </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="abd12983f14c80f7fdc515c793f40cf5f"></a><!-- doxytag: member="HWThread::HWThread" ref="abd12983f14c80f7fdc515c793f40cf5f" args="(uint32_t sampling_rate, uint16_t channels, uint16_t blocks)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HWThread::HWThread </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>sampling_rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>blocks</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sampling_rate</em>&nbsp;</td><td>Sampling rate of the device. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>channels</em>&nbsp;</td><td>Number of channels the device acquires. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>blocks</em>&nbsp;</td><td>Blocksize used by the device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2b7ecb5fc242836db457edba0fcac11e"></a><!-- doxytag: member="HWThread::HWThread" ref="a2b7ecb5fc242836db457edba0fcac11e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HWThread::HWThread </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default constructor. </p>
<p>Sets the device to 1 channel, sampling_rate 0 and blocksize 1. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a89a9edf259a4538609b7f4c5be9db14d"></a><!-- doxytag: member="HWThread::checkMandatoryHardwareTags" ref="a89a9edf259a4538609b7f4c5be9db14d" args="(ticpp::Iterator&lt; ticpp::Element &gt; hw)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HWThread::checkMandatoryHardwareTags </td>
          <td>(</td>
          <td class="paramtype">ticpp::Iterator&lt; ticpp::Element &gt;&nbsp;</td>
          <td class="paramname"> <em>hw</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if all needed hardware tags from xml config are correctly set. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hw</em>&nbsp;</td><td>pointing to the &lt;hardware&gt; node in the xml config file </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ticpp::Exception</em>&nbsp;</td><td>if mandatory hardware tags not correctly set! </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="class_h_w_thread_a89a9edf259a4538609b7f4c5be9db14d_cgraph.png" border="0" usemap="#class_h_w_thread_a89a9edf259a4538609b7f4c5be9db14d_cgraph_map" alt=""></div>
<map name="class_h_w_thread_a89a9edf259a4538609b7f4c5be9db14d_cgraph_map" id="class_h_w_thread_a89a9edf259a4538609b7f4c5be9db14d_cgraph">
<area shape="rect" href="class_constants.html#a9a808751c766b2f77cc13362b2064d76" title="Checks, if the given string equals &quot;master&quot;." alt="" coords="324,5,489,35"/><area shape="rect" href="class_constants.html#a55fe8c5ab386f56f6860f9c153800219" title="Checks, if the given string equals &quot;slave&quot;." alt="" coords="327,59,487,88"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="aa709526a915411a495a947f6bc6e06f9"></a><!-- doxytag: member="HWThread::getAsyncData" ref="aa709526a915411a495a947f6bc6e06f9" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_sample_block.html">SampleBlock</a>&lt;double&gt; HWThread::getAsyncData </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Abstract method to achieve asynchronous data acquisition (method is non-blocking). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="class_sample_block.html">SampleBlock&lt;double&gt;</a></dd></dl>
<p>This method return immediately after calling with a copy of the data stored in the device's buffer. It is called from all slave devices. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>If hardware clocks are not running with the same sampling rate or drifting (e.g. master - 128Hz, slave 129Hz), this method could be called although no new data is available (master faster than slave) or one sample has been lost (master slower than slave). Up to now no compensation method (e.g. interpolation) has been implemented! </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd>Implement a compensation method, if clocks are drifting or similar (e.g. interpolation). </dd></dl>

<p>Implemented in <a class="el" href="class_sine_generator.html#ad609b16d89e1d1c762cd94023ea41439">SineGenerator</a>, and <a class="el" href="class_u_s_bamp.html#a645a210ffbc5931560f91c8ee6896300">USBamp</a>.</p>

</div>
</div>
<a class="anchor" id="a7ea386811b40278f26d54eef9c700c08"></a><!-- doxytag: member="HWThread::getChannelInfoMap" ref="a7ea386811b40278f26d54eef9c700c08" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt;uint16_t, pair&lt;string, uint32_t&gt; &gt; HWThread::getChannelInfoMap </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a map containing all channel information. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>std::map&lt;uint16_t channel, pair&lt;string channel name, uint32_t channel type&gt; &gt; channel info </dd></dl>

</div>
</div>
<a class="anchor" id="a655f5d40b6ae44cd59db936df49a5c07"></a><!-- doxytag: member="HWThread::getChannelTypes" ref="a655f5d40b6ae44cd59db936df49a5c07" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;uint32_t&gt; HWThread::getChannelTypes </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a vector containing channel types from acquired channels. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>std::vector&lt;uint16_t&gt; channel_types </dd></dl>

</div>
</div>
<a class="anchor" id="a052a0eb8639dda07c3b25df7066194fa"></a><!-- doxytag: member="HWThread::getName" ref="a052a0eb8639dda07c3b25df7066194fa" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string HWThread::getName </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the name of the device. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>string device name </dd></dl>

</div>
</div>
<a class="anchor" id="a563ffea63c9ee8878f91a7b1f04eb58a"></a><!-- doxytag: member="HWThread::getNrOfBlocks" ref="a563ffea63c9ee8878f91a7b1f04eb58a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t HWThread::getNrOfBlocks </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the blocksize set for the device. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>uint16_t blocksize </dd></dl>

</div>
</div>
<a class="anchor" id="a18e32ba3ca6621edd899196113e1e213"></a><!-- doxytag: member="HWThread::getNrOfChannels" ref="a18e32ba3ca6621edd899196113e1e213" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t HWThread::getNrOfChannels </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the number of channels the device is acquiering. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>uint16_t nr_of_ch </dd></dl>

</div>
</div>
<a class="anchor" id="acd129796e88e58d3ef2e157e5cbdd156"></a><!-- doxytag: member="HWThread::getSamplingRate" ref="acd129796e88e58d3ef2e157e5cbdd156" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t HWThread::getSamplingRate </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the sampling rate set for the device. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>uint16_t sampling_rate </dd></dl>

</div>
</div>
<a class="anchor" id="add1215b3e0f06a856330f2debd7ea2fe"></a><!-- doxytag: member="HWThread::getSyncData" ref="add1215b3e0f06a856330f2debd7ea2fe" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_sample_block.html">SampleBlock</a>&lt;double&gt; HWThread::getSyncData </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Abstract method to achieve synchronous data acquisition (method is blocking). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="class_sample_block.html">SampleBlock&lt;double&gt;</a></dd></dl>
<p>This method returns after new data has been acquired, it is operating in blocking mode. It is called only from the master device. </p>

<p>Implemented in <a class="el" href="class_sine_generator.html#a7c239c664d3559988889cd5d9f90d854">SineGenerator</a>, and <a class="el" href="class_u_s_bamp.html#ae5aa6002d425924a95d102f1d890c84c">USBamp</a>.</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="class_h_w_thread_add1215b3e0f06a856330f2debd7ea2fe_icgraph.png" border="0" usemap="#class_h_w_thread_add1215b3e0f06a856330f2debd7ea2fe_icgraph_map" alt=""></div>
<map name="class_h_w_thread_add1215b3e0f06a856330f2debd7ea2fe_icgraph_map" id="class_h_w_thread_add1215b3e0f06a856330f2debd7ea2fe_icgraph">
<area shape="rect" href="class_h_w_access.html#a99d0f4c10e9def70d1189fc6c2100a20" title="Retreive a DataPacket containing data from attached hardware synchronous with the..." alt="" coords="219,5,397,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="aaab242a33f6739fae59ce7a48d892072"></a><!-- doxytag: member="HWThread::hasHomogenousSignalType" ref="aaab242a33f6739fae59ce7a48d892072" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HWThread::hasHomogenousSignalType </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if device is delivering only one SignalType (e.g. only EEG or only EMG). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>bool </dd></dl>

</div>
</div>
<a class="anchor" id="a0ee653e71f6ac92c96d5d9df2bd986e1"></a><!-- doxytag: member="HWThread::isMaster" ref="a0ee653e71f6ac92c96d5d9df2bd986e1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HWThread::isMaster </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if device is the master. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>bool </dd></dl>

</div>
</div>
<a class="anchor" id="afc7da1ef263177f3108dcc318208dc60"></a><!-- doxytag: member="HWThread::isNumber" ref="afc7da1ef263177f3108dcc318208dc60" args="(const std::string &amp;s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HWThread::isNumber </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check, if a string represents a valid number. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>bool </dd></dl>

</div>
</div>
<a class="anchor" id="a240b66ff60434938ca89690cd542dc58"></a><!-- doxytag: member="HWThread::samplesAvailable" ref="a240b66ff60434938ca89690cd542dc58" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HWThread::samplesAvailable </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if new samples are available. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>bool </dd></dl>

</div>
</div>
<a class="anchor" id="a8c3dada5e55e8e29eadf41e2097ec80a"></a><!-- doxytag: member="HWThread::setBlocks" ref="a8c3dada5e55e8e29eadf41e2097ec80a" args="(ticpp::Iterator&lt; ticpp::Element &gt;const &amp;elem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HWThread::setBlocks </td>
          <td>(</td>
          <td class="paramtype">ticpp::Iterator&lt; ticpp::Element &gt;const &amp;&nbsp;</td>
          <td class="paramname"> <em>elem</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the blocksize of the device. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>elem</em>&nbsp;</td><td>pointing to the &lt;buffersize&gt; node in the xml config file </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ticpp::Exception</em>&nbsp;</td><td>if sampling rate is not a number or is zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6ed2a51d2a3a7b9313d1c33f5f507c57"></a><!-- doxytag: member="HWThread::setChannelSelection" ref="a6ed2a51d2a3a7b9313d1c33f5f507c57" args="(ticpp::Iterator&lt; ticpp::Element &gt;const &amp;elem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HWThread::setChannelSelection </td>
          <td>(</td>
          <td class="paramtype">ticpp::Iterator&lt; ticpp::Element &gt;const &amp;&nbsp;</td>
          <td class="paramname"> <em>elem</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set different parameters for channels (and overwrite settings from &lt;measurement_channels&gt;). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>elem</em>&nbsp;</td><td>pointing to the &lt;channel_selection&gt; node in the xml config file </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ticpp::Exception</em>&nbsp;</td><td>if attributes are not correctly set or nr of channels is not a number or zero.</td></tr>
  </table>
  </dd>
</dl>
<p>This method also reports, if settings for all channels together have been defined before and overwrites those settings. </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="class_h_w_thread_a6ed2a51d2a3a7b9313d1c33f5f507c57_cgraph.png" border="0" usemap="#class_h_w_thread_a6ed2a51d2a3a7b9313d1c33f5f507c57_cgraph_map" alt=""></div>
<map name="class_h_w_thread_a6ed2a51d2a3a7b9313d1c33f5f507c57_cgraph_map" id="class_h_w_thread_a6ed2a51d2a3a7b9313d1c33f5f507c57_cgraph">
<area shape="rect" href="class_constants.html#a381d9729953ee019bca64e42d89005e7" title="Maps a given string to the respective SignalType flag." alt="" coords="276,5,444,35"/><area shape="rect" href="class_h_w_thread.html#af0a839e6a139fa0a261a589a6df07de3" title="Sets the vector channel_types." alt="" coords="264,59,456,88"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a379eecae202ad9b740e08ac22b5d7a42"></a><!-- doxytag: member="HWThread::setDeviceChannels" ref="a379eecae202ad9b740e08ac22b5d7a42" args="(ticpp::Iterator&lt; ticpp::Element &gt;const &amp;elem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HWThread::setDeviceChannels </td>
          <td>(</td>
          <td class="paramtype">ticpp::Iterator&lt; ticpp::Element &gt;const &amp;&nbsp;</td>
          <td class="paramname"> <em>elem</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set parameters for all channels. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>elem</em>&nbsp;</td><td>pointing to the &lt;measurement_channels&gt; node in the xml config file </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ticpp::Exception</em>&nbsp;</td><td>if attributes are not correctly set or nr of channels is not a number or zero. </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="class_h_w_thread_a379eecae202ad9b740e08ac22b5d7a42_cgraph.png" border="0" usemap="#class_h_w_thread_a379eecae202ad9b740e08ac22b5d7a42_cgraph_map" alt=""></div>
<map name="class_h_w_thread_a379eecae202ad9b740e08ac22b5d7a42_cgraph_map" id="class_h_w_thread_a379eecae202ad9b740e08ac22b5d7a42_cgraph">
<area shape="rect" href="class_constants.html#a381d9729953ee019bca64e42d89005e7" title="Maps a given string to the respective SignalType flag." alt="" coords="268,5,436,35"/><area shape="rect" href="class_h_w_thread.html#af0a839e6a139fa0a261a589a6df07de3" title="Sets the vector channel_types." alt="" coords="256,59,448,88"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a1bd5e440e5f86d0d9af928577c52b262"></a><!-- doxytag: member="HWThread::setSamplingRate" ref="a1bd5e440e5f86d0d9af928577c52b262" args="(ticpp::Iterator&lt; ticpp::Element &gt;const &amp;elem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HWThread::setSamplingRate </td>
          <td>(</td>
          <td class="paramtype">ticpp::Iterator&lt; ticpp::Element &gt;const &amp;&nbsp;</td>
          <td class="paramname"> <em>elem</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the sampling rate of the device. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>elem</em>&nbsp;</td><td>pointing to the &lt;sampling_rate&gt; node in the xml config file </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ticpp::Exception</em>&nbsp;</td><td>if sampling rate is not a number or is zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a64aa44932b8914a5623aa2f1efd4e149"></a><!-- doxytag: member="HWThread::data" ref="a64aa44932b8914a5623aa2f1efd4e149" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sample_block.html">SampleBlock</a>&lt;double&gt; <a class="el" href="class_h_w_thread.html#a64aa44932b8914a5623aa2f1efd4e149">HWThread::data</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Data object representing the last available samples from the <a class="el" href="class_sine_generator.html" title="A dummy hardware device for simulation and testing purposes.">SineGenerator</a>. </p>
<p>This <a class="el" href="class_sample_block.html" title="A container storing and sorting samples directly acquired from a data acquisition...">SampleBlock</a> contains the last affordable data for external components. If the buffersize is 1 , than samples will directly be inserted into data, in blockwise mode, "buffer" will be copied into "data", if the desired number of blocks is achieved. Samples are in ascending order by their signal type. "data" has to be secured by a mutex to cope with the reader/writer problem, as asynchronous data access is also possible. For more information, read the <a class="el" href="class_sample_block.html" title="A container storing and sorting samples directly acquired from a data acquisition...">SampleBlock</a> documentation. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/breidi/Dropbox/signalserver/hardware/<a class="el" href="hw__thread_8h_source.html">hw_thread.h</a></li>
<li>/home/breidi/Dropbox/signalserver/hardware/hw_thread.cpp</li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Thu Nov 12 16:55:50 2009 for TOBI SignalServer by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
